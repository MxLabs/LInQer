"use strict";var Linqer;!function(t){t.Enumerable.prototype.shuffle=function(){const e=this;const n=t.Enumerable.from((function*(){const t=e.toArray(),n=t.length;let o=0;for(;o<n;){let e=o+Math.floor(Math.random()*(n-o));const r=t[e];t[e]=t[o],t[o]=r,o++,yield r}}));return n._count=()=>e.count(),n},t.Enumerable.prototype.randomSample=function(e,n=Number.MAX_SAFE_INTEGER){let o=0;const r=[];if(t._ensureInternalTryGetAt(this),this._canSeek){const t=this.count();let o=0;for(o=0;o<e&&o<n&&o<t;o++)r.push(this.elementAt(o));let a=Math.exp(Math.log(Math.random())/e);for(;o<t&&o<n;)o+=Math.floor(Math.log(Math.random())/Math.log(1-a))+1,o<t&&o<n&&(r[Math.floor(Math.random()*e)]=this.elementAt(o),a*=Math.exp(Math.log(Math.random())/e))}else for(const t of this){if(o<e)r.push(t);else{const n=Math.floor(Math.random()*o);n<e&&(r[n]=t)}if(o++,o>=n)break}return t.Enumerable.from(r)},t.Enumerable.prototype.distinctByHash=function(e){const n=this;return new t.Enumerable((function*(){const t=new Set;for(const o of n){const n=t.size;t.add(e(o)),n<t.size&&(yield o)}}))},t.Enumerable.prototype.exceptByHash=function(e,n){t._ensureIterable(e);const o=this;return new t.Enumerable((function*(){const r=t.Enumerable.from(e).select(n).toSet();for(const t of o)r.has(n(t))||(yield t)}))},t.Enumerable.prototype.intersectByHash=function(e,n){t._ensureIterable(e);const o=this;return new t.Enumerable((function*(){const r=t.Enumerable.from(e).select(n).toSet();for(const t of o)r.has(n(t))&&(yield t)}))},t.Enumerable.prototype.binarySearch=function(e,n=t._defaultComparer){let o=this.toList(),r=0,a=o.count()-1;for(;r<=a;){const t=r+a>>1,s=n(o.elementAt(t),e);if(0==s)return t;s<0?r=t+1:a=t-1}return!1},t.Enumerable.prototype.lag=function(e,n){if(!e)throw new Error("offset has to be positive");if(e<0)throw new Error("offset has to be positive. Use .lead if you want to join with next items");n?t._ensureFunction(n):n=(t,e)=>[t,e];const o=this;t._ensureInternalTryGetAt(this);const r=new t.Enumerable((function*(){const t=Array(e);let r=0;for(const a of o){const o=r-e,s=o<0?void 0:t[o%e];yield n(a,s),t[r%e]=a,r++}}));return r._count=()=>{const t=o.count();return r._wasIterated||(r._wasIterated=o._wasIterated),t},o._canSeek&&(r._canSeek=!0,r._tryGetAt=t=>{const r=o._tryGetAt(t),a=o._tryGetAt(t-e);return r?{value:n(r.value,a?a.value:void 0)}:null}),r},t.Enumerable.prototype.lead=function(e,n){if(!e)throw new Error("offset has to be positive");if(e<0)throw new Error("offset has to be positive. Use .lag if you want to join with previous items");n?t._ensureFunction(n):n=(t,e)=>[t,e];const o=this;t._ensureInternalTryGetAt(this);const r=new t.Enumerable((function*(){const t=Array(e);let r=0;for(const a of o){const o=r-e;if(o>=0){const r=t[o%e];yield n(r,a)}t[r%e]=a,r++}for(let o=0;o<e;o++){const a=t[(r+o)%e];yield n(a,void 0)}}));return r._count=()=>{const t=o.count();return r._wasIterated||(r._wasIterated=o._wasIterated),t},o._canSeek&&(r._canSeek=!0,r._tryGetAt=t=>{const r=o._tryGetAt(t),a=o._tryGetAt(t+e);return r?{value:n(r.value,a?a.value:void 0)}:null}),r},t.Enumerable.prototype.padEnd=function(e,n){if(e<=0)throw new Error("minLength has to be positive.");let o;o="function"!=typeof n?t=>n:n;const r=this;t._ensureInternalTryGetAt(this);const a=new t.Enumerable((function*(){let t=0;for(const e of r)yield e,t++;for(;t<e;t++)yield o(t)}));return a._count=()=>{const t=Math.max(e,r.count());return a._wasIterated||(a._wasIterated=r._wasIterated),t},r._canSeek&&(a._canSeek=!0,a._tryGetAt=t=>{const n=r._tryGetAt(t);return n||(t<e?{value:o(t)}:null)}),a},t.Enumerable.prototype.padStart=function(e,n){if(e<=0)throw new Error("minLength has to be positive.");let o;o="function"!=typeof n?t=>n:n;const r=this;t._ensureInternalTryGetAt(r);const a=new t.Enumerable((function*(){const t=Array(e);let n=0;const a=r[Symbol.iterator]();let s=!1,u=!1;do{const r=a.next();if(u=!!r.done,u||(t[n]=r.value,n++),s&&!u)yield r.value;else if(u||n===e){for(let t=0;t<e-n;t++)yield o(t);for(let e=0;e<n;e++)yield t[e];s=!0}}while(!u)}));return a._count=()=>{const t=Math.max(e,r.count());return a._wasIterated||(a._wasIterated=r._wasIterated),t},r._canSeek&&(a._canSeek=!0,a._tryGetAt=t=>{const n=r.count(),a=e-n;return a<=0?r._tryGetAt(t):t<a?{value:o(t)}:r._tryGetAt(t-a)}),a}}(Linqer||(Linqer={}));